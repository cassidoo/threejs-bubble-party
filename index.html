<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Party</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <img id="background" src="https://images.unsplash.com/photo-1561283890-5d858c23b2ea?q=80&w=1976&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D" />
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        let scene, camera, renderer;
        let bubbles = [];
        let mouse = new THREE.Vector2();
        let lastBubbleTime = 0;
        const bubbleDelay = 250; // Much slower bubble creation
        let envMap;
        let bubbleSizes = [0.4, 0.5, 0.6, 0.7]; // Larger bubbles
        const SPAWN_DISTANCE = 10; // Distance at which bubbles appear (farther away)
        
        function init() {
            // Create scene with black background to match reference
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Set up camera with wider field of view
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8; // Camera further back

            // Set up renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                premultipliedAlpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            document.body.appendChild(renderer.domElement);

            // Create a cube texture for environment mapping (more colorful)
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
                format: THREE.RGBAFormat,
                generateMipmaps: true,
                minFilter: THREE.LinearMipmapLinearFilter
            });
            
            // Load HDR environment map for realistic reflections
            const rgbeLoader = new RGBELoader();
            rgbeLoader.load('https://threejs.org/examples/textures/equirectangular/venice_sunset_1k.hdr', function(texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                envMap = texture;
                
                // Start the scene
                setupLights();
                addEventListeners();
                animate();
            });
        }

        function setupLights() {
            // Create vivid colored lighting to match reference image
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            // Add point lights with vibrant colors matching the reference photo
            const colors = [
                0xff00ff, // Magenta
                0xff3399, // Pink
                0x33ccff, // Cyan
                0x00ffcc, // Teal
                0xccff00, // Lime
                0xffcc00  // Gold
            ];
            
            colors.forEach((color, index) => {
                const intensity = 2;
                const pointLight = new THREE.PointLight(color, intensity, 50);
                // Position lights in a sphere around the center
                const radius = 10;
                const phi = Math.PI * Math.random();
                const theta = 2 * Math.PI * Math.random();
                
                pointLight.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                scene.add(pointLight);
            });
            
            // Add a stronger central light
            const centralLight = new THREE.PointLight(0xffffff, 1, 50);
            centralLight.position.set(0, 0, 2);
            scene.add(centralLight);
        }

        function addEventListeners() {
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove);
            window.addEventListener('resize', onWindowResize);
        }

        function createBubble(x, y) {
            // Random size from our size array (larger than before)
            const size = bubbleSizes[Math.floor(Math.random() * bubbleSizes.length)];
            const geometry = new THREE.SphereGeometry(size, 64, 64); // Higher poly count for smoother look
            
            // Create transparent base material with thin shell
            const bubbleMaterial = new THREE.MeshPhysicalMaterial({
                transparent: true,
                opacity: 0.15, // Very transparent interior
                metalness: 0.1,
                roughness: 0.05,
                transmission: 0.99, // Nearly full transmission
                thickness: 0.002, // Very thin shell
                envMap: envMap,
                envMapIntensity: 3.0, // Strong reflections
                clearcoat: 1.0,
                clearcoatRoughness: 0.0, // Perfect clearcoat
                ior: 1.4, // Water-like refraction
                side: THREE.DoubleSide,
                premultipliedAlpha: true,
                iridescence: 1.0,
                iridescenceIOR: 1.2,
                reflectivity: 1.0
            });
            
            // Create bubble
            const bubble = new THREE.Mesh(geometry, bubbleMaterial);
            
            // Create world position for bubble emergence (farther away from camera)
            const vector = new THREE.Vector3();
            vector.set(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1,
                0.5
            );
            vector.unproject(camera);
            
            const direction = vector.sub(camera.position).normalize();
            const distance = SPAWN_DISTANCE; // Spawn far away from camera
            const farPosition = camera.position.clone().add(direction.multiplyScalar(distance));
            
            // Add slight randomness to starting position
            bubble.position.set(
                farPosition.x + (Math.random() - 0.5) * 1,
                farPosition.y + (Math.random() - 0.5) * 1,
                farPosition.z + (Math.random() - 0.5) * 1
            );
            
            // More gentle, realistic motion
            const baseSpeed = 0.005;
            bubble.velocity = {
                x: (Math.random() - 0.5) * baseSpeed,
                y: 0.005 + Math.random() * baseSpeed, // Gentle upward drift
                z: (Math.random() - 0.5) * baseSpeed
            };

            // Gentler rotation
            bubble.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.001,
                y: (Math.random() - 0.5) * 0.001,
                z: (Math.random() - 0.5) * 0.001
            };
            
            // Natural movement parameters
            bubble.wobblePhase = Math.random() * Math.PI * 2;
            bubble.wobbleSpeed = 0.2 + Math.random() * 0.3; // Slower wobble
            bubble.wobbleAmount = 0.0005 + Math.random() * 0.001; // Subtle wobble
            bubble.airResistance = 0.999; // Very light air resistance
            bubble.lifetime = 400 + Math.random() * 200; // Longer lifetime
            bubble.maxLifetime = bubble.lifetime;
            
            scene.add(bubble);
            bubbles.push(bubble);
            
            // Add a colorful edge highlight (matches reference photo)
            addBubbleEdgeHighlight(bubble, size);
        }
        
        function addBubbleEdgeHighlight(bubble, size) {
            // Create a slightly larger, very thin shell for the colored edge
            const edgeGeometry = new THREE.SphereGeometry(size * 1.001, 64, 64);
            
            // Choose a vibrant color for the edge (cycle through colors similar to reference)
            const edgeColors = [
                new THREE.Color(0xff00ff), // Magenta
                new THREE.Color(0xff3399), // Pink
                new THREE.Color(0x33ccff), // Cyan
                new THREE.Color(0x00ffcc), // Teal
                new THREE.Color(0xccff00), // Lime
                new THREE.Color(0xffcc00)  // Gold
            ];
            
            const edgeColor = edgeColors[Math.floor(Math.random() * edgeColors.length)];
            
            const edgeMaterial = new THREE.MeshPhysicalMaterial({
                color: edgeColor,
                transparent: true,
                opacity: 0.7,
                metalness: 0,
                roughness: 0,
                transmission: 0.5,
                thickness: 0.001,
                envMap: envMap,
                envMapIntensity: 2.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0,
                side: THREE.DoubleSide,
                premultipliedAlpha: true,
                depthWrite: false
            });
            
            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            bubble.add(edge); // Parent to the bubble
            bubble.edge = edge;
        }

        function onMouseMove(event) {
            mouse.x = event.clientX;
            mouse.y = event.clientY;
            
            const currentTime = Date.now();
            if (currentTime - lastBubbleTime > bubbleDelay) {
                // Create bubbles less frequently for more natural effect
                createBubble(mouse.x, mouse.y);
                lastBubbleTime = currentTime;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            mouse.x = touch.clientX;
            mouse.y = touch.clientY;
            
            const currentTime = Date.now();
            if (currentTime - lastBubbleTime > bubbleDelay) {
                createBubble(mouse.x, mouse.y);
                lastBubbleTime = currentTime;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update bubble positions with more natural motion
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const bubble = bubbles[i];
                
                // Update position
                bubble.position.x += bubble.velocity.x;
                bubble.position.y += bubble.velocity.y;
                bubble.position.z += bubble.velocity.z;
                
                // More natural motion - gentler wobble
                const time = Date.now() * 0.001;
                const wobbleX = Math.sin(time * bubble.wobbleSpeed + bubble.wobblePhase) * bubble.wobbleAmount;
                const wobbleZ = Math.cos(time * bubble.wobbleSpeed + bubble.wobblePhase) * bubble.wobbleAmount;
                bubble.position.x += wobbleX;
                bubble.position.z += wobbleZ;
                
                // Very light air resistance
                bubble.velocity.x *= bubble.airResistance;
                bubble.velocity.y *= bubble.airResistance;
                bubble.velocity.z *= bubble.airResistance;
                
                // Gentle breeze effect
                if (Math.random() < 0.05) { // Only occasionally
                    bubble.velocity.x += (Math.random() - 0.5) * 0.0002;
                    bubble.velocity.z += (Math.random() - 0.5) * 0.0002;
                }
                
                // Very subtle rotation - more realistic
                bubble.rotation.x += bubble.rotationSpeed.x;
                bubble.rotation.y += bubble.rotationSpeed.y;
                bubble.rotation.z += bubble.rotationSpeed.z;
                
                // Update lifetime and fade out
                bubble.lifetime--;
                if (bubble.lifetime < 100) {
                    // Fade both the bubble and its edge
                    const fadeRatio = bubble.lifetime / 100;
                    bubble.material.opacity = 0.15 * fadeRatio;
                    
                    if (bubble.edge) {
                        bubble.edge.material.opacity = 0.7 * fadeRatio;
                    }
                }
                
                // Distance-based effect: bubbles get more transparent as they approach the camera
                const distanceToCamera = bubble.position.distanceTo(camera.position);
                if (distanceToCamera < 5) {
                    const opacityFactor = Math.max(0, (distanceToCamera - 2) / 3);
                    bubble.material.opacity = Math.min(bubble.material.opacity, 0.15 * opacityFactor);
                    if (bubble.edge) {
                        bubble.edge.material.opacity = Math.min(bubble.edge.material.opacity, 0.7 * opacityFactor);
                    }
                }
                
                // Remove bubbles that have expired or gone too far
                if (bubble.lifetime <= 0 || 
                    bubble.position.y > 20 || 
                    bubble.position.y < -20 || 
                    bubble.position.x < -20 || 
                    bubble.position.x > 20) {
                    scene.remove(bubble);
                    bubbles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // Initialize the scene
        init();
    </script>
</body>
</html>